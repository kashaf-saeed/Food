{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst functions_js_1 = require(\"@supabase/functions-js\");\nconst postgrest_js_1 = require(\"@supabase/postgrest-js\");\nconst realtime_js_1 = require(\"@supabase/realtime-js\");\nconst storage_js_1 = require(\"@supabase/storage-js\");\nconst constants_1 = require(\"./lib/constants\");\nconst fetch_1 = require(\"./lib/fetch\");\nconst helpers_1 = require(\"./lib/helpers\");\nconst SupabaseAuthClient_1 = require(\"./lib/SupabaseAuthClient\");\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nclass SupabaseClient {\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.storage Options passed along to the storage-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   * @example\n   * ```ts\n   * import { createClient } from '@supabase/supabase-js'\n   *\n   * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n   * const { data } = await supabase.from('profiles').select('*')\n   * ```\n   */\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c;\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    const baseUrl = (0, helpers_1.validateSupabaseUrl)(supabaseUrl);\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n    this.realtimeUrl = new URL('realtime/v1', baseUrl);\n    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws');\n    this.authUrl = new URL('auth/v1', baseUrl);\n    this.storageUrl = new URL('storage/v1', baseUrl);\n    this.functionsUrl = new URL('functions/v1', baseUrl);\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`;\n    const DEFAULTS = {\n      db: constants_1.DEFAULT_DB_OPTIONS,\n      realtime: constants_1.DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, constants_1.DEFAULT_AUTH_OPTIONS), {\n        storageKey: defaultStorageKey\n      }),\n      global: constants_1.DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = (0, helpers_1.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n    } else {\n      this.accessToken = settings.accessToken;\n      this.auth = new Proxy({}, {\n        get: (_, prop) => {\n          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n        }\n      });\n    }\n    this.fetch = (0, fetch_1.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this)\n    }, settings.realtime));\n    if (this.accessToken) {\n      // Start auth immediately to avoid race condition with channel subscriptions\n      this.accessToken().then(token => this.realtime.setAuth(token)).catch(e => console.warn('Failed to set initial Realtime auth token:', e));\n    }\n    this.rest = new postgrest_js_1.PostgrestClient(new URL('rest/v1', baseUrl).href, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch\n    });\n    this.storage = new storage_js_1.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n    if (!settings.accessToken) {\n      this._listenForAuthEvents();\n    }\n  }\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new functions_js_1.FunctionsClient(this.functionsUrl.href, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation) {\n    return this.rest.from(relation);\n  }\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema(schema) {\n    return this.rest.schema(schema);\n  }\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc(fn, args = {}, options = {\n    head: false,\n    get: false,\n    count: undefined\n  }) {\n    return this.rest.rpc(fn, args, options);\n  }\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name, opts = {\n    config: {}\n  }) {\n    return this.realtime.channel(name, opts);\n  }\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n  async _getAccessToken() {\n    var _a, _b;\n    if (this.accessToken) {\n      return await this.accessToken();\n    }\n    const {\n      data\n    } = await this.auth.getSession();\n    return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n  }\n  _initSupabaseAuthClient({\n    autoRefreshToken,\n    persistSession,\n    detectSessionInUrl,\n    storage,\n    userStorage,\n    storageKey,\n    flowType,\n    lock,\n    debug,\n    throwOnError\n  }, headers, fetch) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`\n    };\n    return new SupabaseAuthClient_1.SupabaseAuthClient({\n      url: this.authUrl.href,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      userStorage,\n      flowType,\n      lock,\n      debug,\n      throwOnError,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: Object.keys(this.headers).some(key => key.toLowerCase() === 'authorization')\n    });\n  }\n  _initRealtimeClient(options) {\n    return new realtime_js_1.RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), {\n      params: Object.assign({\n        apikey: this.supabaseKey\n      }, options === null || options === void 0 ? void 0 : options.params)\n    }));\n  }\n  _listenForAuthEvents() {\n    const data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n    });\n    return data;\n  }\n  _handleTokenChanged(event, source, token) {\n    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n      this.changedAccessToken = token;\n      this.realtime.setAuth(token);\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth();\n      if (source == 'STORAGE') this.auth.signOut();\n      this.changedAccessToken = undefined;\n    }\n  }\n}\nexports.default = SupabaseClient;","map":{"version":3,"names":["functions_js_1","require","postgrest_js_1","realtime_js_1","storage_js_1","constants_1","fetch_1","helpers_1","SupabaseAuthClient_1","SupabaseClient","constructor","supabaseUrl","supabaseKey","options","baseUrl","validateSupabaseUrl","Error","realtimeUrl","URL","protocol","replace","authUrl","storageUrl","functionsUrl","defaultStorageKey","hostname","split","DEFAULTS","db","DEFAULT_DB_OPTIONS","realtime","DEFAULT_REALTIME_OPTIONS","auth","Object","assign","DEFAULT_AUTH_OPTIONS","storageKey","global","DEFAULT_GLOBAL_OPTIONS","settings","applySettingDefaults","_a","headers","_b","accessToken","_initSupabaseAuthClient","_c","fetch","Proxy","get","_","prop","String","fetchWithAuth","_getAccessToken","bind","_initRealtimeClient","then","token","setAuth","catch","e","console","warn","rest","PostgrestClient","href","schema","storage","StorageClient","_listenForAuthEvents","functions","FunctionsClient","customFetch","from","relation","rpc","fn","args","head","count","undefined","channel","name","opts","config","getChannels","removeChannel","removeAllChannels","data","getSession","session","access_token","autoRefreshToken","persistSession","detectSessionInUrl","userStorage","flowType","lock","debug","throwOnError","authHeaders","Authorization","apikey","SupabaseAuthClient","url","hasCustomAuthorizationHeader","keys","some","key","toLowerCase","RealtimeClient","params","onAuthStateChange","event","_handleTokenChanged","source","changedAccessToken","signOut","exports","default"],"sources":["E:\\react\\fooding web\\my-app\\node_modules\\@supabase\\supabase-js\\src\\SupabaseClient.ts"],"sourcesContent":["import type { AuthChangeEvent } from '@supabase/auth-js'\nimport { FunctionsClient } from '@supabase/functions-js'\nimport {\n  PostgrestClient,\n  type PostgrestFilterBuilder,\n  type PostgrestQueryBuilder,\n} from '@supabase/postgrest-js'\nimport {\n  type RealtimeChannel,\n  type RealtimeChannelOptions,\n  RealtimeClient,\n  type RealtimeClientOptions,\n} from '@supabase/realtime-js'\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\nimport {\n  DEFAULT_AUTH_OPTIONS,\n  DEFAULT_DB_OPTIONS,\n  DEFAULT_GLOBAL_OPTIONS,\n  DEFAULT_REALTIME_OPTIONS,\n} from './lib/constants'\nimport { fetchWithAuth } from './lib/fetch'\nimport { applySettingDefaults, validateSupabaseUrl } from './lib/helpers'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport type {\n  Fetch,\n  GenericSchema,\n  SupabaseAuthClientOptions,\n  SupabaseClientOptions,\n} from './lib/types'\nimport { GetRpcFunctionFilterBuilderByArgs } from './lib/rest/types/common/rpc'\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient<\n  Database = any,\n  // The second type parameter is also used for specifying db_schema, so we\n  // support both cases.\n  // TODO: Allow setting db_schema from ClientOptions.\n  SchemaNameOrClientOptions extends\n    | (string & keyof Omit<Database, '__InternalSupabase'>)\n    | { PostgrestVersion: string } = 'public' extends keyof Omit<Database, '__InternalSupabase'>\n    ? 'public'\n    : string & keyof Omit<Database, '__InternalSupabase'>,\n  SchemaName extends string &\n    keyof Omit<Database, '__InternalSupabase'> = SchemaNameOrClientOptions extends string &\n    keyof Omit<Database, '__InternalSupabase'>\n    ? SchemaNameOrClientOptions\n    : 'public' extends keyof Omit<Database, '__InternalSupabase'>\n      ? 'public'\n      : string & keyof Omit<Omit<Database, '__InternalSupabase'>, '__InternalSupabase'>,\n  Schema extends Omit<Database, '__InternalSupabase'>[SchemaName] extends GenericSchema\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\n    : never = Omit<Database, '__InternalSupabase'>[SchemaName] extends GenericSchema\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\n    : never,\n  ClientOptions extends { PostgrestVersion: string } = SchemaNameOrClientOptions extends string &\n    keyof Omit<Database, '__InternalSupabase'>\n    ? // If the version isn't explicitly set, look for it in the __InternalSupabase object to infer the right version\n      Database extends { __InternalSupabase: { PostgrestVersion: string } }\n      ? Database['__InternalSupabase']\n      : // otherwise default to 12\n        { PostgrestVersion: '12' }\n    : SchemaNameOrClientOptions extends { PostgrestVersion: string }\n      ? SchemaNameOrClientOptions\n      : never,\n> {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n  realtime: RealtimeClient\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  storage: SupabaseStorageClient\n\n  protected realtimeUrl: URL\n  protected authUrl: URL\n  protected storageUrl: URL\n  protected functionsUrl: URL\n  protected rest: PostgrestClient<Database, ClientOptions, SchemaName>\n  protected storageKey: string\n  protected fetch?: Fetch\n  protected changedAccessToken?: string\n  protected accessToken?: () => Promise<string | null>\n\n  protected headers: Record<string, string>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.storage Options passed along to the storage-js constructor.\n   * @param options.global.fetch A custom fetch implementation.\n   * @param options.global.headers Any additional headers to send with each network request.\n   * @example\n   * ```ts\n   * import { createClient } from '@supabase/supabase-js'\n   *\n   * const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n   * const { data } = await supabase.from('profiles').select('*')\n   * ```\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions<SchemaName>\n  ) {\n    const baseUrl = validateSupabaseUrl(supabaseUrl)\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    this.realtimeUrl = new URL('realtime/v1', baseUrl)\n    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws')\n    this.authUrl = new URL('auth/v1', baseUrl)\n    this.storageUrl = new URL('storage/v1', baseUrl)\n    this.functionsUrl = new URL('functions/v1', baseUrl)\n\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\n      global: DEFAULT_GLOBAL_OPTIONS,\n    }\n\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\n\n    this.storageKey = settings.auth.storageKey ?? ''\n    this.headers = settings.global.headers ?? {}\n\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient(\n        settings.auth ?? {},\n        this.headers,\n        settings.global.fetch\n      )\n    } else {\n      this.accessToken = settings.accessToken\n\n      this.auth = new Proxy<SupabaseAuthClient>({} as any, {\n        get: (_, prop) => {\n          throw new Error(\n            `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(\n              prop\n            )} is not possible`\n          )\n        },\n      })\n    }\n\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch)\n    this.realtime = this._initRealtimeClient({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this),\n      ...settings.realtime,\n    })\n    if (this.accessToken) {\n      // Start auth immediately to avoid race condition with channel subscriptions\n      this.accessToken()\n        .then((token) => this.realtime.setAuth(token))\n        .catch((e) => console.warn('Failed to set initial Realtime auth token:', e))\n    }\n\n    this.rest = new PostgrestClient(new URL('rest/v1', baseUrl).href, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch,\n    })\n\n    this.storage = new SupabaseStorageClient(\n      this.storageUrl.href,\n      this.headers,\n      this.fetch,\n      options?.storage\n    )\n\n    if (!settings.accessToken) {\n      this._listenForAuthEvents()\n    }\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions(): FunctionsClient {\n    return new FunctionsClient(this.functionsUrl.href, {\n      headers: this.headers,\n      customFetch: this.fetch,\n    })\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.from\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName],\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any> {\n    return this.rest.from(relation)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    ClientOptions,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return this.rest.schema<DynamicSchema>(schema)\n  }\n\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FnName extends string & keyof Schema['Functions'],\n    Args extends Schema['Functions'][FnName]['Args'] = never,\n    FilterBuilder extends GetRpcFunctionFilterBuilderByArgs<\n      Schema,\n      FnName,\n      Args\n    > = GetRpcFunctionFilterBuilderByArgs<Schema, FnName, Args>,\n  >(\n    fn: FnName,\n    args: Args = {} as Args,\n    options: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {\n      head: false,\n      get: false,\n      count: undefined,\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    FilterBuilder['Row'],\n    FilterBuilder['Result'],\n    FilterBuilder['RelationName'],\n    FilterBuilder['Relationships'],\n    'RPC'\n  > {\n    return this.rest.rpc(fn, args, options) as unknown as PostgrestFilterBuilder<\n      ClientOptions,\n      Schema,\n      FilterBuilder['Row'],\n      FilterBuilder['Result'],\n      FilterBuilder['RelationName'],\n      FilterBuilder['Relationships'],\n      'RPC'\n    >\n  }\n\n  /**\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n   *\n   * @param {string} name - The name of the Realtime channel.\n   * @param {Object} opts - The options to pass to the Realtime channel.\n   *\n   */\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\n    return this.realtime.channel(name, opts)\n  }\n\n  /**\n   * Returns all Realtime channels.\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.realtime.getChannels()\n  }\n\n  /**\n   * Unsubscribes and removes Realtime channel from Realtime client.\n   *\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\n   *\n   */\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\n    return this.realtime.removeChannel(channel)\n  }\n\n  /**\n   * Unsubscribes and removes all Realtime channels from Realtime client.\n   */\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\n    return this.realtime.removeAllChannels()\n  }\n\n  private async _getAccessToken() {\n    if (this.accessToken) {\n      return await this.accessToken()\n    }\n\n    const { data } = await this.auth.getSession()\n\n    return data.session?.access_token ?? this.supabaseKey\n  }\n\n  private _initSupabaseAuthClient(\n    {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      userStorage,\n      storageKey,\n      flowType,\n      lock,\n      debug,\n      throwOnError,\n    }: SupabaseAuthClientOptions,\n    headers?: Record<string, string>,\n    fetch?: Fetch\n  ) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl.href,\n      headers: { ...authHeaders, ...headers },\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      userStorage,\n      flowType,\n      lock,\n      debug,\n      throwOnError,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: Object.keys(this.headers).some(\n        (key) => key.toLowerCase() === 'authorization'\n      ),\n    })\n  }\n\n  private _initRealtimeClient(options: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl.href, {\n      ...options,\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\n    })\n  }\n\n  private _listenForAuthEvents() {\n    const data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    source: 'CLIENT' | 'STORAGE',\n    token?: string\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      this.changedAccessToken = token\n      this.realtime.setAuth(token)\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth()\n      if (source == 'STORAGE') this.auth.signOut()\n      this.changedAccessToken = undefined\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}